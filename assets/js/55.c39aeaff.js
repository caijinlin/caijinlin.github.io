(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{328:function(t,n,e){"use strict";e.r(n);var s=e(14),a=Object(s.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("p",[n("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/caijinlin/imgcdn/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Slice.png",alt:""}})]),t._v(" "),n("blockquote",[n("p",[t._v("看完这篇文章，下面这些高频面试题你都会答了吧")])]),t._v(" "),n("ol",[n("li",[t._v("Go slice的底层实现原理")]),t._v(" "),n("li",[t._v("Go array和slice的区别")]),t._v(" "),n("li",[t._v("Go slice深拷贝和浅拷贝")]),t._v(" "),n("li",[t._v("Go slice扩容机制是怎样的？")]),t._v(" "),n("li",[t._v("为什么Go slice是非线程安全的？")])]),t._v(" "),n("h2",{attrs:{id:"实现原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#实现原理"}},[t._v("#")]),t._v(" 实现原理")]),t._v(" "),n("p",[t._v("slice是无固定长度的数组，底层结构是一个结构体，包含如下3个属性")]),t._v(" "),n("p",[t._v("一个 "),n("code",[t._v("slice")]),t._v(" 在 golang 中占用 24 个 bytes")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("type slice struct {\n\tarray unsafe.Pointer \n\tlen   int \n\tcap   int \n}\n")])])]),n("p",[t._v("array : 包含了一个指向一个数组的指针，数据实际上存储在这个指针指向的数组上，占用 8 bytes")]),t._v(" "),n("p",[t._v("len:  当前 slice 使用到的长度，占用8 bytes")]),t._v(" "),n("p",[t._v("cap :  当前 slice 的容量，同时也是底层数组 array 的长度， 8 bytes")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/caijinlin/imgcdn/1605449197795-9ca02de7-b129-4f7c-a0c3-930798b881c0.svg",alt:""}})]),t._v(" "),n("p",[t._v("slice并不是真正意义上的动态数组，而是一个引用类型。slice总是指向一个底层array，slice的声明也可以像 array一样，只是长度可变。"),n("strong",[t._v("golang中通过语法糖，使得我们可以像声明array一样，自动创建slice结构体")])]),t._v(" "),n("p",[n("em",[t._v("根据")]),t._v("索引位置取切片"),n("em",[t._v("slice")]),t._v(" 元素值时，默认取值范围是（0～"),n("em",[t._v("len")]),t._v("("),n("em",[t._v("slice")]),t._v(")-1），一般输出slice时，通常是指 slice[0:len(slice)-1]，根据下标就可以输出所指向底层数组中的值")]),t._v(" "),n("h2",{attrs:{id:"主要特性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#主要特性"}},[t._v("#")]),t._v(" 主要特性")]),t._v(" "),n("h3",{attrs:{id:"引用类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#引用类型"}},[t._v("#")]),t._v(" 引用类型")]),t._v(" "),n("p",[t._v("golang 有三个常用的高级类型"),n("em",[t._v("slice")]),t._v("、map、channel, 它们都是"),n("em",[t._v("引用类型")]),t._v("，当引用类型作为函数参数时，可能会修改原内容数据。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("func sliceModify(s []int) {\n\ts[0] = 100\n}\n\nfunc sliceAppend(s []int) []int {\n\ts = append(s, 100)\n\treturn s\n}\n\nfunc sliceAppendPtr(s *[]int) {\n\t*s = append(*s, 100)\n\treturn\n}\n\n// 注意：Go语言中所有的传参都是值传递（传值），都是一个副本，一个拷贝。\n// 拷贝的内容是非引用类型（int、string、struct等这些），在函数中就无法修改原内容数据；\n// 拷贝的内容是引用类型（interface、指针、map、slice、chan等这些），这样就可以修改原内容数据。\nfunc TestSliceFn(t *testing.T) {\n\t// 参数为引用类型slice：外层slice的len/cap不会改变，指向的底层数组会改变\n\ts := []int{1, 1, 1}\n\tnewS := sliceAppend(s)\n\t// 函数内发生了扩容\n\tt.Log(s, len(s), cap(s))\n\t// [1 1 1] 3 3\n\tt.Log(newS, len(newS), cap(newS)) \n\t// [1 1 1 100] 4 6\n\n\ts2 := make([]int, 0, 5)\n\tnewS = sliceAppend(s2)\n\t// 函数内未发生扩容\n\tt.Log(s2, s2[0:5], len(s2), cap(s2)) \n\t// [] [100 0 0 0 0] 0 5\n\tt.Log(newS, newS[0:5], len(newS), cap(newS))\n\t// [100] [100 0 0 0 0] 1 5\n\n\t// 参数为引用类型slice的指针：外层slice的len/cap会改变，指向的底层数组会改变\n\tsliceAppendPtr(&s)\n\tt.Log(s, len(s), cap(s)) \n  // [1 1 1 100] 4 6\n\tsliceModify(s)\n\tt.Log(s, len(s), cap(s)) \n  // [100 1 1 100] 4 6\n}\n")])])]),n("p",[t._v("公众号后台caspar回复【代码】获取本文所有示例代码")]),t._v(" "),n("h3",{attrs:{id:"切片状态"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#切片状态"}},[t._v("#")]),t._v(" 切片状态")]),t._v(" "),n("p",[t._v("切片有3种特殊的状态，分为「零切片」、「空切片」和「nil 切片」")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('func TestSliceEmptyOrNil(t *testing.T) {\n\tvar slice1 []int           \n  // slice1 is nil slice\n\tslice2 := make([]int, 0)    \n\t// slcie2 is empty slice\n\tvar slice3 = make([]int, 2) \n\t// slice3 is zero slice\n\tif slice1 == nil {\n\t\tt.Log("slice1 is nil.") \n\t\t// 会输出这行\n\t}\n\tif slice2 == nil {\n\t\tt.Log("slice2 is nil.") \n\t\t// 不会输出这行\n\t}\n\tt.Log(slice3) // [0 0]\n}\n')])])]),n("h3",{attrs:{id:"非线程安全"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#非线程安全"}},[t._v("#")]),t._v(" 非线程安全")]),t._v(" "),n("p",[t._v("slice不支持并发读写，所以并不是线程安全的，使用多个 goroutine 对类型为 slice 的变量进行操作，每次输出的值大概率都不会一样，与预期值不一致;  slice在并发执行中不会报错，但是数据会丢失")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("/**\n* 切片非并发安全\n* 多次执行，每次得到的结果都不一样\n* 可以考虑使用 channel 本身的特性 (阻塞) 来实现安全的并发读写\n */\nfunc TestSliceConcurrencySafe(t *testing.T) {\n\ta := make([]int, 0)\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < 10000; i++ {\n\t\twg.Add(1)\n\t\tgo func(i int) {\n\t\t\ta = append(a, i)\n\t\t\twg.Done()\n\t\t}(i)\n\t}\n\twg.Wait()\n\tt.Log(len(a)) \n\t// not equal 10000\n}\n\n")])])]),n("p",[t._v("如果想实现slice线程安全，有两种方式：")]),t._v(" "),n("p",[t._v("方式一：通过加锁实现slice线程安全，适合对性能要求不高的场景。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("func TestSliceConcurrencySafeByMutex(t *testing.T) {\n\tvar lock sync.Mutex //互斥锁\n\ta := make([]int, 0)\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < 10000; i++ {\n\t\twg.Add(1)\n\t\tgo func(i int) {\n\t\t\tdefer wg.Done()\n\t\t\tlock.Lock()\n\t\t\tdefer lock.Unlock()\n\t\t\ta = append(a, i)\n\t\t}(i)\n\t}\n\twg.Wait()\n\tt.Log(len(a)) \n\t// equal 10000\n}\n")])])]),n("p",[t._v("方式二：通过channel实现slice线程安全，适合对性能要求高的场景。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("func TestSliceConcurrencySafeByChanel(t *testing.T) {\n\tbuffer := make(chan int)\n\ta := make([]int, 0)\n\t// 消费者\n\tgo func() {\n\t\tfor v := range buffer {\n\t\t\ta = append(a, v)\n\t\t}\n\t}()\n\t// 生产者\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < 10000; i++ {\n\t\twg.Add(1)\n\t\tgo func(i int) {\n\t\t\tdefer wg.Done()\n\t\t\tbuffer <- i\n\t\t}(i)\n\t}\n\twg.Wait()\n\tt.Log(len(a)) \n\t// equal 10000\n}\n")])])]),n("h3",{attrs:{id:"共享存储空间"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#共享存储空间"}},[t._v("#")]),t._v(" 共享存储空间")]),t._v(" "),n("p",[t._v("多个切片如果共享同一个底层数组，这种情况下，对其中一个切片或者底层数组的更改，会影响到其他切片")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('/**\n* 切片共享存储空间\n */\nfunc TestSliceShareMemory(t *testing.T) {\n\tslice1 := []string{"1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"}\n\tQ2 := slice1[3:6]\n\tt.Log(Q2, len(Q2), cap(Q2)) \n\t// [4 5 6] 3 9\n\tQ3 := slice1[5:8]\n\tt.Log(Q3, len(Q3), cap(Q3)) \n\t// [6 7 8] 3 7\n\tQ3[0] = "Unkown"\n\tt.Log(Q2, Q3) \n\t// [4 5 Unkown] [Unkown 7 8]\n\n\ta := []int{1, 2, 3, 4, 5}\n\tshadow := a[1:3]\n\tt.Log(shadow, a)             \n\t// [2 3] [1 2 3 4 5]\n\tshadow = append(shadow, 100) \n\t// 会修改指向数组的所有切片\n\tt.Log(shadow, a)            \n  // [2 3 100] [1 2 3 100 5]\n}\n')])])]),n("h2",{attrs:{id:"常用操作"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#常用操作"}},[t._v("#")]),t._v(" 常用操作")]),t._v(" "),n("h3",{attrs:{id:"创建"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#创建"}},[t._v("#")]),t._v(" 创建")]),t._v(" "),n("p",[t._v("slice 的创建有4种方式，如下：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("func TestSliceInit(t *testing.T) {\n\t// 初始化方式1：直接声明\n\tvar slice1 []int\n\tt.Log(len(slice1), cap(slice1)) \n\t// 0, 0\n\tslice1 = append(slice1, 1)\n\tt.Log(len(slice1), cap(slice1)) \n\t// 1, 1, 24\n\n\t// 初始化方式2：使用字面量\n\tslice2 := []int{1, 2, 3, 4}\n\tt.Log(len(slice2), cap(slice2)) \n\t// 4, 4, 24\n\n\t// 初始化方式3：使用make创建slice\n\tslice3 := make([]int, 3, 5)           \n  // make([]T, len, cap) cap不传则和len一样\n\tt.Log(len(slice3), cap(slice3))       \n  // 3, 5\n\tt.Log(slice3[0], slice3[1], slice3[2]) \n\t// 0, 0, 0\n\t// t.Log(slice3[3], slice3[4]) \n\t// panic: runtime error: index out of range [3] with length 3\n\tslice3 = append(slice3, 1)\n\tt.Log(len(slice3), cap(slice3)) \n\t// 4, 5, 24\n\n\t// 初始化方式4: 从切片或数组“截取”\n\tarr := [100]int{}\n\tfor i := range arr {\n\t\tarr[i] = i\n\t}\n\tslcie4 := arr[1:3]\n\tslice5 := make([]int, len(slcie4))\n\tcopy(slice5, slcie4)\n\tt.Log(len(slcie4), cap(slcie4), unsafe.Sizeof(slcie4)) \n\t// 2，99，24\n\tt.Log(len(slice5), cap(slice5), unsafe.Sizeof(slice5)) \n\t// 2，2，24\n}\n")])])]),n("h3",{attrs:{id:"增加"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#增加"}},[t._v("#")]),t._v(" 增加")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("func TestSliceGrowing(t *testing.T) {\n\tslice1 := []int{}\n\tfor i := 0; i < 10; i++ {\n\t\tslice1 = append(slice1, i)\n\t\tt.Log(len(slice1), cap(slice1))\n\t}\n\t// 1 1\n\t// 2 2\n\t// 3 4\n\t// 4 4\n\t// 5 8\n\t// 6 8\n\t// 7 8\n\t// 8 8\n\t// 9 16\n\t// 10 16\n}\n")])])]),n("h3",{attrs:{id:"删除"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#删除"}},[t._v("#")]),t._v(" 删除")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("func TestSliceDelete(t *testing.T) {\n\tslice1 := []int{1, 2, 3, 4, 5}\n\tvar x int\n\t// 删除最后一个元素\n\tx, slice1 = slice1[len(slice1)-1], slice1[:len(slice1)-1] \n\tt.Log(x, slice1, len(slice1), cap(slice1)) \n\t// 5 [1 2 3 4] 4 5\n\n\t// 删除第2个元素\t\n\tslice1 = append(slice1[:2], slice1[3:]...) \n\tt.Log(slice1, len(slice1), cap(slice1))    \n\t// [1 2 4] 3 5\n}\n")])])]),n("h3",{attrs:{id:"查找"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#查找"}},[t._v("#")]),t._v(" 查找")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("v := s[i] // 下标访问\n")])])]),n("h3",{attrs:{id:"修改"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#修改"}},[t._v("#")]),t._v(" 修改")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("s[i] = 5 // 下标修改\n")])])]),n("h3",{attrs:{id:"截取"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#截取"}},[t._v("#")]),t._v(" 截取")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("/**\n* 切片截取\n */\nfunc TestSliceSubstr(t *testing.T) {\n\tslice1 := []int{1, 2, 3, 4, 5}\n\tslice2 := slice1[:]\n\t// 截取 slice[left:right:max]\n\t// left：省略默认0\n\t// right：省略默认len(slice1)\n\t// max: 省略默认len(slice1)\n\t// len = right-left+1\n\t// cap = max-left\n\tt.Log(slice2, len(slice2), cap(slice2)) \n\t// 1 2 3 4 5] 5 5\n\tslice3 := slice1[1:]\n\tt.Log(slice3, len(slice3), cap(slice3)) \n\t// [2 3 4 5] 4 4\n\tslice4 := slice1[:2]\n\tt.Log(slice4, len(slice4), cap(slice4)) \n\t// [1 2] 2 5\n\tslice5 := slice1[1:2]\n\tt.Log(slice5, len(slice5), cap(slice5)) \n\t// [2] 1 4\n\tslice6 := slice1[:2:5]\n\tt.Log(slice6, len(slice6), cap(slice6)) \n\t// [1 2] 2 5\n\tslice7 := slice1[1:2:2]\n\tt.Log(slice7, len(slice7), cap(slice7)) \n\t// [2] 1 1\n}\n")])])]),n("h3",{attrs:{id:"遍历"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#遍历"}},[t._v("#")]),t._v(" 遍历")]),t._v(" "),n("p",[t._v("切片有3种遍历方式")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("/**\n* 切片遍历\n */\nfunc TestSliceTravel(t *testing.T) {\n\tslice1 := []int{1, 2, 3, 4}\n\tfor i := 0; i < len(slice1); i++ {\n\t\tt.Log(slice1[i])\n\t}\n\tfor idx, e := range slice1 {\n\t\tt.Log(idx, e)\n\t}\n\tfor _, e := range slice1 {\n\t\tt.Log(e)\n\t}\n}\n")])])]),n("h3",{attrs:{id:"反转"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#反转"}},[t._v("#")]),t._v(" 反转")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("func TestSliceReverse(t *testing.T) {\n\ta := []int{1, 2, 3, 4, 5}\n\tfor left, right := 0, len(a)-1; left < right; left, right = left+1, right-1 {\n\t\ta[left], a[right] = a[right], a[left]\n\t}\n\tt.Log(a, len(a), cap(a)) \n\t// [5 4 3 2 1] 5 5\n}\n")])])]),n("h3",{attrs:{id:"拷贝"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#拷贝"}},[t._v("#")]),t._v(" 拷贝")]),t._v(" "),n("p",[t._v("开发中会经常的把一个变量复制给另一个变量，那么这个过程，可能是深浅拷贝，那么今天帮大家区分一下这两个拷贝的区别和具体的区别")]),t._v(" "),n("h4",{attrs:{id:"深拷贝"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#深拷贝"}},[t._v("#")]),t._v(" 深拷贝")]),t._v(" "),n("p",[t._v("拷贝的是数据本身，创造一个样的新对象，新创建的对象与原对象不共享内存，新创建的对象在内存中开辟一个新的内存地址，新对象值修改时不会影响原对象值。既然内存地址不同，释放内存地址时，可分别释放")]),t._v(" "),n("p",[t._v("值类型的数据，默认赋值操作都是深拷贝，Array、Int、String、Struct、Float，Bool。引用类型的数据如果想实现深拷贝，需要通过辅助函数完成")]),t._v(" "),n("p",[t._v("比如golang深拷贝copy 方法会把源切片值(即 from Slice )中的元素复制到目标切片(即 to Slice )中，并返回被复制的元素个数，copy 的两个类型必须一致。copy 方法最终的"),n("strong",[t._v("复制结果取决于较短的那个切片")]),t._v("，当较短的切片复制完成，整个复制过程就全部完成了")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("/**\n* 深拷贝\n */\nfunc TestSliceDeepCopy(t *testing.T) {\n\tslice1 := []int{1, 2, 3, 4, 5}\n\tslice2 := make([]int, 5, 5)\n\t// 深拷贝\n\tcopy(slice2, slice1)                   \n\tt.Log(slice1, len(slice1), cap(slice1)) \n\t// [1 2 3 4 5] 5 5\n\tt.Log(slice2, len(slice2), cap(slice2)) \n\t// [1 2 3 4 5] 5 5\n\tslice1[1] = 100                        \n\tt.Log(slice1, len(slice1), cap(slice1)) \n\t// [1 100 3 4 5] 5 5\n\tt.Log(slice2, len(slice2), cap(slice2)) \n\t// [1 2 3 4 5] 5 5\n}\n")])])]),n("h4",{attrs:{id:"浅拷贝"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#浅拷贝"}},[t._v("#")]),t._v(" 浅拷贝")]),t._v(" "),n("p",[t._v("拷贝的是数据地址，只复制指向的对象的指针，此时新对象和老对象指向的内存地址是一样的，新对象值修改时老对象也会变化。释放内存地址时，同时释放内存地址。")]),t._v(" "),n("p",[t._v("引用类型的数据，默认全部都是浅拷贝，Slice、Map等")]),t._v(" "),n("p",[t._v("目的切片和源切片指向同一个底层数组，任何一个数组元素改变，都会同时影响两个数组。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('/**\n* 浅拷贝\n */\nfunc TestSliceShadowCopy(t *testing.T) {\n\tslice1 := []int{1, 2, 3, 4, 5}\n\t// 浅拷贝（注意 := 对于引用类型是浅拷贝，对于值类型是深拷贝）\n\tslice2 := slice1     \n\tt.Logf("%p", slice1) // 0xc00001c120\n\tt.Logf("%p", slice2) // 0xc00001c120\n\t// 同时改变两个数组，这时就是浅拷贝，未扩容时，修改 slice1 的元素之后，slice2 的元素也会跟着修改\n\tslice1[0] = 10\n\tt.Log(slice1, len(slice1), cap(slice1)) \n\t// [10 2 3 4 5] 5 5\n\tt.Log(slice2, len(slice2), cap(slice2)) \n\t// [10 2 3 4 5] 5 5\n\t// 注意下：扩容后，slice1和slice2不再指向同一个数组，修改 slice1 的元素之后，slice2 的元素不会被修改了\n\tslice1 = append(slice1, 5, 6, 7, 8)\n\tslice1[0] = 11   \n  // 这里可以发现，slice1[0] 被修改为了 11, slice1[0] 还是10\n\tt.Log(slice1, len(slice1), cap(slice1)) \n\t// [11 2 3 4 5 5 6 7 8] 9 10\n\tt.Log(slice2, len(slice2), cap(slice2))\n  // [10 2 3 4 5] 5 5\n}\n')])])]),n("p",[n("strong",[t._v("在复制 slice 的时候，slice 中数组的指针也被复制了，在触发扩容逻辑之前，两个 slice 指向的是相同的数组，触发扩容逻辑之后指向的就是不同的数组了")])]),t._v(" "),n("h2",{attrs:{id:"扩容"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#扩容"}},[t._v("#")]),t._v(" 扩容")]),t._v(" "),n("p",[t._v("扩容会发生在slice append的时候，当slice的cap不足以容纳新元素，就会进行扩容")]),t._v(" "),n("p",[t._v("源码：https://github.com/golang/go/blob/master/src/runtime/slice.go")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("func growslice(et *_type, old slice, cap int) slice {\n\t  // 省略一些判断...\n    newcap := old.cap\n    doublecap := newcap + newcap\n    if cap > doublecap {\n        newcap = cap\n    } else {\n        if old.len < 1024 {\n            newcap = doublecap\n        } else {\n            // Check 0 < newcap to detect overflow\n            // and prevent an infinite loop.\n            for 0 < newcap && newcap < cap {\n                newcap += newcap / 4\n            }\n            // Set newcap to the requested cap when\n            // the newcap calculation overflowed.\n            if newcap <= 0 {\n                newcap = cap\n            }\n        }\n    }\n    // 省略一些后续...\n}\n")])])]),n("ul",[n("li",[t._v("如果新申请容量比两倍原有容量大，那么扩容后容量大小 等于 新申请容量")]),t._v(" "),n("li",[t._v("如果原有 slice 长度小于 1024， 那么每次就扩容为原来的 2 倍")]),t._v(" "),n("li",[t._v("如果原 slice 大于等于 1024， 那么每次扩容就扩为原来的 1.25 倍")])]),t._v(" "),n("h1",{attrs:{id:"内存泄露"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#内存泄露"}},[t._v("#")]),t._v(" 内存泄露")]),t._v(" "),n("p",[t._v("由于slice的底层是数组，很可能数组很大，但slice所取的元素数量却很小，这就导致数组占用的绝大多数空间是被浪费的")]),t._v(" "),n("p",[t._v("Case1:")]),t._v(" "),n("p",[t._v("比如下面的代码，如果传入的"),n("code",[t._v("slice b")]),t._v("是很大的，然后引用很小部分给全局量"),n("code",[t._v("a")]),t._v("，那么"),n("code",[t._v("b")]),t._v("未被引用的部分（下标1之后的数据）就不会被释放，造成了所谓的内存泄漏。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var a []int\n\nfunc test(b []int) {\n\ta = b[:1] // 和b共用一个底层数组\n\treturn\n}\n")])])]),n("p",[t._v("那么只要全局量"),n("code",[t._v("a")]),t._v("在，"),n("code",[t._v("b")]),t._v("就不会被回收。")]),t._v(" "),n("p",[t._v("如何避免？")]),t._v(" "),n("p",[t._v("在这样的场景下注意：如果我们只用到一个slice的一小部分，那么底层的整个数组也将继续保存在内存当中。当这个底层数组很大，或者这样的场景很多时，可能会造成内存急剧增加，造成崩溃。")]),t._v(" "),n("p",[t._v("所以在这样的场景下，我们可以将需要的分片复制到一个新的slice中去，减少内存的占用")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var a []int\n\nfunc test(b []int) {\n\ta = make([]int, 1)\n\tcopy(a, b[:0])\n\treturn\n}\n")])])]),n("p",[t._v("Case2:")]),t._v(" "),n("p",[t._v("比如下面的代码，返回的slice是很小一部分，这样该函数退出后，原来那个体积较大的底层数组也无法被回收")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("func test2() []int{\n\ts = make([]int, 0, 10000)\n\tfor i := 0; i < 10000; i++ {\n\t\ts = append(s, p)\n\t}\n\ts2 := s[100:102]\n\treturn s2\n}\n")])])]),n("p",[t._v("如何避免？")]),t._v(" "),n("p",[t._v("将需要的分片复制到一个新的slice中去，减少内存的占用")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("func test2() []int{\n\ts = make([]int, 0, 10000)\n\tfor i := 0; i < 10000; i++ {\n\t  // 一些计算...\n\t\ts = append(s, p)\n\t}\n\ts2 := make([]int, 2)\n\tcopy(s2, s[100:102])\n\treturn s2\n}\n")])])]),n("h1",{attrs:{id:"切片与数组对比"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#切片与数组对比"}},[t._v("#")]),t._v(" 切片与数组对比")]),t._v(" "),n("p",[t._v("数组是一个固定长度的，初始化时候必须要指定长度，不指定长度的话就是切片了")]),t._v(" "),n("p",[t._v("数组是值类型，将一个数组赋值给另一个数组时，传递的是一份深拷贝，赋值和函数传参操作都会复制整个数组数据，会占用额外的内存；切片是引用类型，将一个切片赋值给另一个切片时，传递的是一份浅拷贝，赋值和函数传参操作只会复制len和cap，但底层共用同一个数组，不会占用额外的内存。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("//a是一个数组，注意数组是一个固定长度的，初始化时候必须要指定长度，不指定长度的话就是切片了\na := [3]int{1, 2, 3}\n//b是数组，是a的一份深拷贝\nb := a\n//c是切片，是引用类型，底层数组是a\nc := a[:]\nfor i := 0; i < len(a); i++ {\n a[i] = a[i] + 1\n}\n//改变a的值后，b是a的拷贝，b不变，c是引用，c的值改变\nfmt.Println(a) \n//[2,3,4]\nfmt.Println(b) \n//[1 2 3]\nfmt.Println(c) \n//[2,3,4]\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("//a是一个切片，不指定长度的话就是切片了\na := []int{1, 2, 3}\n//b是切片，是a的一份拷贝\nb := a\n//c是切片，是引用类型\nc := a[:]\nfor i := 0; i < len(a); i++ {\n a[i] = a[i] + 1\n}\n//改变a的值后，b是a的浅拷贝，b的值改派，c是引用，c的值改变\nfmt.Println(a) \n//[2,3,4]\nfmt.Println(b) \n//[2,3,4]\nfmt.Println(c) \n//[2,3,4]\n")])])]),n("h1",{attrs:{id:"总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),n("ul",[n("li",[t._v("创建切片时可根据实际需要预分配容量，尽量避免追加过程中进行扩容操作，有利于提升性能")]),t._v(" "),n("li",[t._v("使用 append() 向切片追加元素时有可能触发扩容，扩容后将会生成新的切片")]),t._v(" "),n("li",[t._v("使用 len()、cap()计算切片长度、容量时，时间复杂度均为 O(1)，不需要遍历切片")]),t._v(" "),n("li",[t._v("切片是非线程安全的，如果要实现线程安全，可以加锁或者使用Channel")]),t._v(" "),n("li",[t._v("大数组作为函数参数时，会复制整个数组数据，消耗过多内存，建议使用切片或者指针")]),t._v(" "),n("li",[t._v("切片作为函数参数时，可以改变切片指向的数组，不能改变切片本身len和cap；想要改变切片本身，可以将改变后的切片返回 或者 将"),n("strong",[t._v("切片指针")]),t._v("作为函数参数。")]),t._v(" "),n("li",[t._v("如果只用到大slice的一小部分，建议将需要的分片复制到一个新的slice中去，减少内存的占用")])])])}),[],!1,null,null,null);n.default=a.exports}}]);