(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{307:function(e,t,n){"use strict";n.r(t);var l=n(14),s=Object(l.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("blockquote",[t("p",[e._v("看完下面这些，高频面试题你都会答了吧")])]),e._v(" "),t("h2",{attrs:{id:"目录"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#目录"}},[e._v("#")]),e._v(" 目录")]),e._v(" "),t("p",[e._v("1、什么是IO多路复用?"),t("br"),e._v("\n2、为什么出现IO多路复用机制?"),t("br"),e._v("\n3、IO多路复用的三种实现方式"),t("br"),e._v("\n4、select函数接口"),t("br"),e._v("\n5、select使用示例"),t("br"),e._v("\n6、select缺点"),t("br"),e._v("\n7、poll函数接口"),t("br"),e._v("\n8、poll使用示例"),t("br"),e._v("\n9、poll缺点"),t("br"),e._v("\n10、epoll函数接口"),t("br"),e._v("\n11、epoll使用示例"),t("br"),e._v("\n12、epoll缺点"),t("br"),e._v("\n13、epoll LT 与 ET模式的区别"),t("br"),e._v("\n14、epoll应用"),t("br"),e._v("\n15、select/poll/epoll之间的区别"),t("br"),e._v("\n16、IO多路复用完整代码实现"),t("br"),e._v("\n17、高频面试题 "),t("br")]),e._v(" "),t("h2",{attrs:{id:"_1、什么是io多路复用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、什么是io多路复用"}},[e._v("#")]),e._v(" 1、什么是IO多路复用")]),e._v(" "),t("p",[t("strong",[e._v("定义")])]),e._v(" "),t("ul",[t("li",[e._v("IO多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄；一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；没有文件句柄就绪时会阻塞应用程序，交出cpu。多路是指网络连接，复用指的是同一个线程")])]),e._v(" "),t("h2",{attrs:{id:"_2、为什么有io多路复用机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、为什么有io多路复用机制"}},[e._v("#")]),e._v(" 2、为什么有IO多路复用机制?")]),e._v(" "),t("blockquote",[t("p",[e._v("没有IO多路复用机制时，有BIO、NIO两种实现方式，但有一些问题")])]),e._v(" "),t("h3",{attrs:{id:"同步阻塞-bio"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#同步阻塞-bio"}},[e._v("#")]),e._v(" 同步阻塞（BIO）")]),e._v(" "),t("ul",[t("li",[e._v("服务端采用单线程，当accept一个请求后，在recv或send调用阻塞时，将无法accept其他请求（必须等上一个请求处recv或send完），"),t("code",[e._v("无法处理并发")])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 伪代码描述\nwhile(1) {\n  // accept阻塞\n  client_fd = accept(listen_fd)\n  fds.append(client_fd)\n  for (fd in fds) {\n    // recv阻塞（会影响上面的accept）\n    if (recv(fd)) {\n      // logic\n    }\n  }  \n}\n")])])]),t("ul",[t("li",[e._v("服务器端采用多线程，当accept一个请求后，开启线程进行recv，可以完成并发处理，但随着请求数增加需要增加系统线程，"),t("code",[e._v("大量的线程占用很大的内存空间，并且线程切换会带来很大的开销，10000个线程真正发生读写事件的线程数不会超过20%，每次accept都开一个线程也是一种资源浪费")])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 伪代码描述\nwhile(1) {\n  // accept阻塞\n  client_fd = accept(listen_fd)\n  // 开启线程read数据（fd增多导致线程数增多）\n  new Thread func() {\n    // recv阻塞（多线程不影响上面的accept）\n    if (recv(fd)) {\n      // logic\n    }\n  }  \n}\n\n")])])]),t("h3",{attrs:{id:"同步非阻塞-nio"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#同步非阻塞-nio"}},[e._v("#")]),e._v(" 同步非阻塞（NIO）")]),e._v(" "),t("ul",[t("li",[e._v("服务器端当accept一个请求后，加入fds集合，每次轮询一遍fds集合recv(非阻塞)数据，没有数据则立即返回错误，"),t("code",[e._v("每次轮询所有fd（包括没有发生读写事件的fd）会很浪费cpu")])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("setNonblocking(listen_fd)\n// 伪代码描述\nwhile(1) {\n  // accept非阻塞（cpu一直忙轮询）\n  client_fd = accept(listen_fd)\n  if (client_fd != null) {\n    // 有人连接\n    fds.append(client_fd)\n  } else {\n    // 无人连接\n  }  \n  for (fd in fds) {\n    // recv非阻塞\n    setNonblocking(client_fd)\n    // recv 为非阻塞命令\n    if (len = recv(fd) && len > 0) {\n      // 有读写数据\n      // logic\n    } else {\n       无读写数据\n    }\n  }  \n}\n")])])]),t("h3",{attrs:{id:"io多路复用-现在的做法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#io多路复用-现在的做法"}},[e._v("#")]),e._v(" IO多路复用（现在的做法）")]),e._v(" "),t("ul",[t("li",[e._v("服务器端采用单线程通过select/epoll等系统调用获取fd列表，遍历有事件的fd进行accept/recv/send，使其能"),t("code",[e._v("支持更多的并发连接请求")])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("fds = [listen_fd]\n// 伪代码描述\nwhile(1) {\n  // 通过内核获取有读写事件发生的fd，只要有一个则返回，无则阻塞\n  // 整个过程只在调用select、poll、epoll这些调用的时候才会阻塞，accept/recv是不会阻塞\n  for (fd in select(fds)) {\n    if (fd == listen_fd) {\n        client_fd = accept(listen_fd)\n        fds.append(client_fd)\n    } elseif (len = recv(fd) && len != -1) { \n      // logic\n    }\n  }  \n}\n")])])]),t("h2",{attrs:{id:"_3、io多路复用的三种实现方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、io多路复用的三种实现方式"}},[e._v("#")]),e._v(" 3、IO多路复用的三种实现方式")]),e._v(" "),t("ul",[t("li",[e._v("select")]),e._v(" "),t("li",[e._v("poll")]),e._v(" "),t("li",[e._v("epoll")])]),e._v(" "),t("h2",{attrs:{id:"_4、select函数接口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4、select函数接口"}},[e._v("#")]),e._v(" 4、select函数接口")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("​#include <sys/select.h>\n#include <sys/time.h>\n\n#define FD_SETSIZE 1024\n#define NFDBITS (8 * sizeof(unsigned long))\n#define __FDSET_LONGS (FD_SETSIZE/NFDBITS)\n\n// 数据结构 (bitmap)\ntypedef struct {\n    unsigned long fds_bits[__FDSET_LONGS];\n} fd_set;\n\n// API\nint select(\n    int max_fd, \n    fd_set *readset, \n    fd_set *writeset, \n    fd_set *exceptset, \n    struct timeval *timeout\n)                              // 返回值就绪描述符的数目\n\nFD_ZERO(int fd, fd_set* fds)   // 清空集合\nFD_SET(int fd, fd_set* fds)    // 将给定的描述符加入集合\nFD_ISSET(int fd, fd_set* fds)  // 判断指定描述符是否在集合中 \nFD_CLR(int fd, fd_set* fds)    // 将给定的描述符从文件中删除  \n")])])]),t("h2",{attrs:{id:"_5、select使用示例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5、select使用示例"}},[e._v("#")]),e._v(" 5、select使用示例")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("int main() {\n  /*\n   * 这里进行一些初始化的设置，\n   * 包括socket建立，地址的设置等,\n   */\n\n  fd_set read_fs, write_fs;\n  struct timeval timeout;\n  int max = 0;  // 用于记录最大的fd，在轮询中时刻更新即可\n\n  // 初始化比特位\n  FD_ZERO(&read_fs);\n  FD_ZERO(&write_fs);\n\n  int nfds = 0; // 记录就绪的事件，可以减少遍历的次数\n  while (1) {\n    // 阻塞获取\n    // 每次需要把fd从用户态拷贝到内核态\n    nfds = select(max + 1, &read_fd, &write_fd, NULL, &timeout);\n    // 每次需要遍历所有fd，判断有无读写事件发生\n    for (int i = 0; i <= max && nfds; ++i) {\n      if (i == listenfd) {\n         --nfds;\n         // 这里处理accept事件\n         FD_SET(i, &read_fd);//将客户端socket加入到集合中\n      }\n      if (FD_ISSET(i, &read_fd)) {\n        --nfds;\n        // 这里处理read事件\n      }\n      if (FD_ISSET(i, &write_fd)) {\n         --nfds;\n        // 这里处理write事件\n      }\n    }\n  }\n")])])]),t("h2",{attrs:{id:"_6、select缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6、select缺点"}},[e._v("#")]),e._v(" 6、select缺点")]),e._v(" "),t("ul",[t("li",[e._v("单个进程所打开的FD是有限制的，通过FD_SETSIZE设置，默认1024（bitmap默认1024）")]),e._v(" "),t("li",[e._v("每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大")]),e._v(" "),t("li",[e._v("对socket扫描时是线性扫描，采用轮询的方法，效率较低（高并发时）")])]),e._v(" "),t("h2",{attrs:{id:"_7、poll函数接口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7、poll函数接口"}},[e._v("#")]),e._v(" 7、poll函数接口")]),e._v(" "),t("blockquote",[t("p",[e._v("poll与select相比，只是没有fd的限制，其它基本一样")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("#include <poll.h>\n// 数据结构\nstruct pollfd {\n    int fd;                         // 需要监视的文件描述符\n    short events;                   // 需要内核监视的事件\n    short revents;                  // 实际发生的事件\n};\n\n// API\nint poll(struct pollfd fds[], nfds_t nfds, int timeout);\n")])])]),t("h2",{attrs:{id:"_8、poll使用示例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8、poll使用示例"}},[e._v("#")]),e._v(" 8、poll使用示例")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 先宏定义长度\n#define MAX_POLLFD_LEN 4096  \n\nint main() {\n  /*\n   * 在这里进行一些初始化的操作，\n   * 比如初始化数据和socket等。\n   */\n\n  int nfds = 0;\n  pollfd fds[MAX_POLLFD_LEN];\n  memset(fds, 0, sizeof(fds));\n  fds[0].fd = listenfd;\n  fds[0].events = POLLRDNORM;\n  int max  = 0;  // 队列的实际长度，是一个随时更新的，也可以自定义其他的\n  int timeout = 0;\n\n  int current_size = max;\n  while (1) {\n    // 阻塞获取\n    // 每次需要把fd从用户态拷贝到内核态\n    nfds = poll(fds, max+1, timeout);\n    if (fds[0].revents & POLLRDNORM) {\n        // 这里处理accept事件\n        connfd = accept(listenfd);\n        //将新的描述符添加到读描述符集合中\n    }\n    // 每次需要遍历所有fd，判断有无读写事件发生\n    for (int i = 1; i < max; ++i) {     \n      if (fds[i].revents & POLLRDNORM) { \n         sockfd = fds[i].fd\n         if ((n = read(sockfd, buf, MAXLINE)) <= 0) {\n            // 这里处理read事件\n            if (n == 0) {\n                close(sockfd);\n                fds[i].fd = -1;\n            }\n         } else {\n             // 这里处理write事件     \n         }\n         if (--nfds <= 0) {\n            break;       \n         }   \n      }\n    }\n  }\n")])])]),t("h2",{attrs:{id:"_9、poll缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9、poll缺点"}},[e._v("#")]),e._v(" 9、poll缺点")]),e._v(" "),t("ul",[t("li",[e._v("每次调用poll，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大")]),e._v(" "),t("li",[e._v("对socket扫描时是线性扫描，采用轮询的方法，效率较低（高并发时）")])]),e._v(" "),t("h2",{attrs:{id:"_10、epoll函数接口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10、epoll函数接口"}},[e._v("#")]),e._v(" 10、epoll函数接口")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("#include <sys/epoll.h>\n\n// 数据结构\n// 每一个epoll对象都有一个独立的eventpoll结构体\n// 用于存放通过epoll_ctl方法向epoll对象中添加进来的事件\n// epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可\nstruct eventpoll {\n    /*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/\n    struct rb_root  rbr;\n    /*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/\n    struct list_head rdlist;\n};\n\n// API\n\nint epoll_create(int size); // 内核中间加一个 ep 对象，把所有需要监听的 socket 都放到 ep 对象中\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); // epoll_ctl 负责把 socket 增加、删除到内核红黑树\nint epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);// epoll_wait 负责检测可读队列，没有可读 socket 则阻塞进程\n")])])]),t("h2",{attrs:{id:"_11、epoll使用示例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_11、epoll使用示例"}},[e._v("#")]),e._v(" 11、epoll使用示例")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("int main(int argc, char* argv[])\n{\n   /*\n   * 在这里进行一些初始化的操作，\n   * 比如初始化数据和socket等。\n   */\n\n    // 内核中创建ep对象\n    epfd=epoll_create(256);\n    // 需要监听的socket放到ep中\n    epoll_ctl(epfd,EPOLL_CTL_ADD,listenfd,&ev);\n \n    while(1) {\n      // 阻塞获取\n      nfds = epoll_wait(epfd,events,20,0);\n      for(i=0;i<nfds;++i) {\n          if(events[i].data.fd==listenfd) {\n              // 这里处理accept事件\n              connfd = accept(listenfd);\n              // 接收新连接写到内核对象中\n              epoll_ctl(epfd,EPOLL_CTL_ADD,connfd,&ev);\n          } else if (events[i].events&EPOLLIN) {\n              // 这里处理read事件\n              read(sockfd, BUF, MAXLINE);\n              //读完后准备写\n              epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&ev);\n          } else if(events[i].events&EPOLLOUT) {\n              // 这里处理write事件\n              write(sockfd, BUF, n);\n              //写完后准备读\n              epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&ev);\n          }\n      }\n    }\n    return 0;\n}\n")])])]),t("h2",{attrs:{id:"_12、epoll缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12、epoll缺点"}},[e._v("#")]),e._v(" 12、epoll缺点")]),e._v(" "),t("ul",[t("li",[e._v("epoll只能工作在linux下")])]),e._v(" "),t("h2",{attrs:{id:"_13、epoll-lt-与-et模式的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_13、epoll-lt-与-et模式的区别"}},[e._v("#")]),e._v(" 13、epoll LT 与 ET模式的区别")]),e._v(" "),t("ul",[t("li",[e._v("epoll有EPOLLLT和EPOLLET两种触发模式，LT是默认的模式，ET是“高速”模式。")]),e._v(" "),t("li",[e._v("LT模式下，只要这个fd还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作")]),e._v(" "),t("li",[e._v("ET模式下，它只会提示一次，直到下次再有数据流入之前都不会再提示了，无论fd中是否还有数据可读。所以在ET模式下，read一个fd的时候一定要把它的buffer读完，或者遇到EAGAIN错误")])]),e._v(" "),t("h2",{attrs:{id:"_14、epoll应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14、epoll应用"}},[e._v("#")]),e._v(" 14、epoll应用")]),e._v(" "),t("ul",[t("li",[e._v("redis")]),e._v(" "),t("li",[e._v("nginx")])]),e._v(" "),t("h2",{attrs:{id:"_15、select-poll-epoll之间的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_15、select-poll-epoll之间的区别"}},[e._v("#")]),e._v(" 15、select/poll/epoll之间的区别")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th"),e._v(" "),t("th",[e._v("select")]),e._v(" "),t("th",[e._v("poll")]),e._v(" "),t("th",[e._v("epoll")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("数据结构")]),e._v(" "),t("td",[e._v("bitmap")]),e._v(" "),t("td",[e._v("数组")]),e._v(" "),t("td",[e._v("红黑树")])]),e._v(" "),t("tr",[t("td",[e._v("最大连接数")]),e._v(" "),t("td",[e._v("1024")]),e._v(" "),t("td",[e._v("无上限")]),e._v(" "),t("td",[e._v("无上限")])]),e._v(" "),t("tr",[t("td",[e._v("fd拷贝")]),e._v(" "),t("td",[e._v("每次调用select拷贝")]),e._v(" "),t("td",[e._v("每次调用poll拷贝")]),e._v(" "),t("td",[e._v("fd首次调用epoll_ctl拷贝，每次调用epoll_wait不拷贝")])]),e._v(" "),t("tr",[t("td",[e._v("工作效率")]),e._v(" "),t("td",[e._v("轮询：O(n)")]),e._v(" "),t("td",[e._v("轮询：O(n)")]),e._v(" "),t("td",[e._v("回调：O(1)")])])])]),e._v(" "),t("h2",{attrs:{id:"_16、完整代码示例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_16、完整代码示例"}},[e._v("#")]),e._v(" 16、完整代码示例")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://github.com/caijinlin/learning-pratice/tree/master/linux/io",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/caijinlin/learning-pratice/tree/master/linux/io"),t("OutboundLink")],1)]),e._v(" "),t("h2",{attrs:{id:"_17、高频面试题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_17、高频面试题"}},[e._v("#")]),e._v(" 17、高频面试题")]),e._v(" "),t("ul",[t("li",[e._v("什么是IO多路复用?")]),e._v(" "),t("li",[e._v("nginx/redis 所使用的IO模型是什么？")]),e._v(" "),t("li",[e._v("select、poll、epoll之间的区别")]),e._v(" "),t("li",[e._v("epoll 水平触发（LT）与 边缘触发（ET）的区别？")])])])}),[],!1,null,null,null);t.default=s.exports}}]);