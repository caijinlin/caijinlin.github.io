(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{343:function(a,t,e){"use strict";e.r(t);var s=e(14),_=Object(s.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"_1-什么是事务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是事务"}},[a._v("#")]),a._v(" 1. 什么是事务")]),a._v(" "),t("p",[a._v("事务由事务开始(begin transaction)和事务结束(end transaction)之间执行的全体操作组成。在关系数据库中，一个事务可以是一组SQL语句或整个程序。")]),a._v(" "),t("h2",{attrs:{id:"_2-事务的四大特性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-事务的四大特性"}},[a._v("#")]),a._v(" 2. 事务的四大特性")]),a._v(" "),t("h2",{attrs:{id:"_3-事务的四大隔离级别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-事务的四大隔离级别"}},[a._v("#")]),a._v(" 3. 事务的四大隔离级别")]),a._v(" "),t("p",[a._v("Read Uncommitted（RU）")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("   在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。\n")])])]),t("p",[a._v("Read Committed（RC）")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("   这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。\n")])])]),t("p",[a._v("Repeatable Read（RR）")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("   这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。\n")])])]),t("p",[a._v("Serializable（可串行化）\n这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。")]),a._v(" "),t("h3",{attrs:{id:"_4-事务并发存在的问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-事务并发存在的问题"}},[a._v("#")]),a._v(" 4. 事务并发存在的问题")]),a._v(" "),t("p",[a._v("脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了其他事务提交的数据。需要注意的是在某些情况下不可重复读并不是问题")]),a._v(" "),t("p",[a._v("幻读和不可重复读都是读取了另一条已经提交的事务(这点就脏读不同)，所不同的是不可重复读可能发生在update,delete操作中，而幻读发生在insert操作中")]),a._v(" "),t("p",[a._v("脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。")]),a._v(" "),t("p",[a._v("不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。")]),a._v(" "),t("p",[a._v("幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的")]),a._v(" "),t("h3",{attrs:{id:"_5-事务四大隔离级别实验"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-事务四大隔离级别实验"}},[a._v("#")]),a._v(" 5. 事务四大隔离级别实验")]),a._v(" "),t("h4",{attrs:{id:"查看隔离级别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#查看隔离级别"}},[a._v("#")]),a._v(" 查看隔离级别")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("select @@global.tx_isolation,@@tx_isolation; \n// 存储引擎系统级的隔离级别和会话级的隔离级别\n")])])]),t("h4",{attrs:{id:"设置隔离级别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设置隔离级别"}},[a._v("#")]),a._v(" 设置隔离级别")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("隔离级别：READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE\nset global transaction isolation level READ COMMITTED; //全局的\nset session transaction isolation level READ COMMITTED; //当前会话\n")])])]),t("h3",{attrs:{id:"_6-mvcc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-mvcc"}},[a._v("#")]),a._v(" 6. MVCC")]),a._v(" "),t("h4",{attrs:{id:"快照读"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#快照读"}},[a._v("#")]),a._v(" 快照读")]),a._v(" "),t("h4",{attrs:{id:"当前读"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#当前读"}},[a._v("#")]),a._v(" 当前读")]),a._v(" "),t("p",[a._v("ABA问题")]),a._v(" "),t("p",[a._v("怎么解决脏读、不可重复读、幻读这些问题呢？其实有两种可选的解决方案：")]),a._v(" "),t("p",[a._v("方案一：读操作利用多版本并发控制（MVCC），写操作进行加锁。")]),a._v(" "),t("p",[a._v("普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录。在READ COMMITTED隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一个ReadView，ReadView的存在本身就保证了事务不可以读取到未提交的事务所做的更改，也就是避免了脏读现象；REPEATABLE READ隔离级别下，一个事务在执行过程中只有第一次执行SELECT操作才会生成一个ReadView，之后的SELECT操作都复用这个ReadView，这样也就避免了不可重复读和幻读的问题")]),a._v(" "),t("p",[a._v("方案二：读、写操作都采用加锁的方式。")]),a._v(" "),t("p",[a._v("脏读的产生是因为当前事务读取了另一个未提交事务写的一条记录，如果另一个事务在写记录的时候就给这条记录加锁，那么当前事务就无法继续读取该记录了，所以也就不会有脏读问题的产生了。不可重复读的产生是因为当前事务先读取一条记录，另外一个事务对该记录做了改动之后并提交之后，当前事务再次读取时会获得不同的值，如果在当前事务读取记录时就给该记录加锁，那么另一个事务就无法修改该记录，自然也不会发生不可重复读了。我们说幻读问题的产生是因为当前事务读取了一个范围的记录，然后另外的事务向该范围内插入了新记录，当前事务再次读取该范围的记录时发现了新插入的新记录，我们把新插入的那些记录称之为幻影记录。采用加锁的方式解决幻读问题就有那么一丢丢麻烦了，因为当前事务在第一次读取记录时那些幻影记录并不存在，所以读取的时候加锁就有点尴尬 —— 因为你并不知道给谁加锁，没关系，这难不倒设计InnoDB的大叔的，我们稍后揭晓答案，稍安勿躁")]),a._v(" "),t("p",[a._v("采用MVCC方式的话，读-写操作彼此并不冲突，性能更高，采用加锁方式的话，读-写操作彼此需要排队执行，影响性能。一般情况下我们当然愿意采用MVCC来解决读-写操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用加锁的方式执行，那也是没有办法的事")]),a._v(" "),t("p",[a._v("快照d")]),a._v(" "),t("p",[a._v("如何解决幻读")]),a._v(" "),t("p",[a._v("幻读和不可重复读都是读取了另一条已经提交的事务(这点就脏读不同)，所不同的是不可重复读可能发生在update,delete操作中，而幻读发生在insert操作中")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("使用串行化读的隔离级别")])]),a._v(" "),t("li",[t("p",[a._v("MVCC+next-key locks：next-key locks由record locks(索引加锁) 和 gap locks(间隙锁，每次锁住的不光是需要使用的数据，还会锁住这些数据附近的数据) 行锁和间隙锁，合称Next-Key Lock")])]),a._v(" "),t("li",[t("p",[a._v("不加锁拥有更高的并发性")])])]),a._v(" "),t("p",[a._v("https://developer.aliyun.com/article/74671\nhttps://juejin.cn/post/6844903799534911496?utm_source=coffeephp.com%3Futm_source%3Dcoffeephp.com#heading-10")]),a._v(" "),t("p",[a._v("https://database.51cto.com/art/202004/613900.htm")])])}),[],!1,null,null,null);t.default=_.exports}}]);