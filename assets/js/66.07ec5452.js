(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{337:function(n,t,s){"use strict";s.r(t);var a=s(14),e=Object(a.a)({},(function(){var n=this,t=n._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"锁的种类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#锁的种类"}},[n._v("#")]),n._v(" 锁的种类")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("- 按照粒度划分：\n    - 表锁\n    - 行锁\n- 按照使用方式划分:\n    - 乐观锁（需自己实现）：\n         - 版本号/时间戳机制 （加version字段）\n         - CAS\n    - 悲观锁（每次操作时都需要获取锁才能对数据进行操作）：\n        - 共享锁\n        - 排它锁\n- 按锁级别划分：\n    - 共享锁 （数据库已实现 lock in share mode）\n    - 排它锁 （数据库已实现 for update）\n")])])]),t("p",[n._v("参考资料：")]),n._v(" "),t("ul",[t("li",[n._v("https://blog.csdn.net/puhaiyang/article/details/72284702")])]),n._v(" "),t("p",[n._v("乐观锁的实现方式主要有两种：CAS机制和版本号机制。CAS机制的原理由CPU支持的原子操作，其原子性是在硬件层面进行保证的。而CAS机制可能会出现ABA问题，即T1读取内存变量为A,T2修改内存变量为B,T2修改内存变量为A,这时T1再CAS操作A时是可行的。但实际上在T1第二次操作A时，已经被其他线程修改过了。")])])}),[],!1,null,null,null);t.default=e.exports}}]);