(window.webpackJsonp=window.webpackJsonp||[]).push([[121],{391:function(t,a,s){"use strict";s.r(a);var e=s(14),c=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("用ab压测服务A(服务A会调用服务B)的时候，并发不大的情况下，经常出现Failed requests，\n最终发现原因是服务B所在服务器tcp半连接队列丢包，导致部分tcp连接不成功，最终请求失败，这里还原下整个过程分析下\n（以下将服务A所在服务器称为客户端，服务B所在服务为服务器端）")]),t._v(" "),a("h3",{attrs:{id:"问题现象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#问题现象"}},[t._v("#")]),t._v(" 问题现象")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("ab 压测出现Failed requests\n")])])]),a("p",[a("img",{attrs:{src:"https://s1.ax1x.com/2020/06/14/tzIm90.md.png",alt:"ab压测"}})]),t._v(" "),a("h3",{attrs:{id:"分析过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分析过程"}},[t._v("#")]),t._v(" 分析过程")]),t._v(" "),a("p",[t._v("1.客户端查看错误日志，看到错误原因")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("net/http: request canceled while waiting for connection\n")])])]),a("p",[t._v("2.服务端根据客户端trace_id查找请求，日志里面找不到，怀疑是tcp层面的问题，也就是连接不成功，还没有进入应用层")]),t._v(" "),a("p",[t._v("3.服务器端查看tcp丢包情况，发现前后两次tcp半连接队列丢包个数相减正好是Failed requests个数")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("# 查看半连接队列 (syn queue) 溢出\nnetstat -s | grep dropped\n# 查看全连接队列 (accept queue) 溢出\nnetstat -s | grep TCPBacklogDrop\n")])])]),a("p",[a("img",{attrs:{src:"https://s1.ax1x.com/2020/06/14/tz4oLQ.md.png",alt:"半连接队列丢包"}})]),t._v(" "),a("p",[t._v("4.查看丢包的原因，服务器端查看半连接队列大小，排除不是设置得过小的原因")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("cat /etc/sysctl.conf | grep net.ipv4.tcp_max_syn_backlog\n")])])]),a("p",[a("img",{attrs:{src:"https://s1.ax1x.com/2020/06/14/tzWLi6.jpg",alt:"TCP握手过程中建连接的流程和队列"}})]),t._v(" "),a("p",[t._v("5.查看丢包的原因，通过查阅资料，服务器同时打开了tcp_timestamps + tcp_tw_recycle时，就会检查时间戳；如果对方发来的包的时间戳是乱跳的或者说时间戳是滞后的，这样服务器肯定不会回复，所以服务器就把带了“倒退”的时间戳的包当作是“recycle的tw连接的重传数据，不是新的请求，于是丢掉客户端的syn请求不回复")]),t._v(" "),a("h3",{attrs:{id:"解决办法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决办法"}},[t._v("#")]),t._v(" 解决办法")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("vim /etc/sysctl.conf \n修改 net.ipv4.tcp_tw_recycle = 0 或者 net.ipv4.tcp_timestamps = 0\n然后sysctl -p 重启\n")])])]),a("h3",{attrs:{id:"参考"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("https://blog.csdn.net/pyxllq/article/details/80351827\nhttps://blog.csdn.net/GV7lZB0y87u7C/article/details/79358193\n")])])])])}),[],!1,null,null,null);a.default=c.exports}}]);